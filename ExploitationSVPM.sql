/*
22 Novembre - 13 Décembre
Simona Bronevitsky 11316059 Yihan Hu 11330613 Jules Lemee 11303810
Le projet consiste à créer et exécuter des requêtes sur la base de données du SPVM pour analyser 
les données d'interventions et générer des rapports. Cela permet d'identifier des tendances, 
d'optimiser la prise de décision, et d'améliorer la gestion des ressources.
*/



/* 
QUESTION 1

Votre superviseur de stage s’interroge sur la faculté de la base de données actuelle à garder trace de changements éventuels d’affectations d’un agent de police à différents postes 
de quartier à travers le temps. En effet, le SPVM est doté d’une politique permettant à un agent de police de changer d’affectation de poste de quartier pendant sa carrière.

1.1.	Expliquer pourquoi la base de données telle que conçue, ne permet pas de consigner convenablement de tels changements d’affectation à travers le temps, afin de pouvoir l’interroger sur ces intervalles de temps d’affectation éventuels.

Actuellement, la relation entre les tables  AGENT et POSTE_DU_QUARTIER fait en sort qu’un agent peut seulement être associé à un poste de quartier à la fois. 
Donc, si un agent est affecté à un autre poste, cette nouvelle information remplacera l’ancienne et l’ancienne ne sera pas conservée dans la base de données.
Aussi, ce qui n’est pas très convenable c’est le fait qu’il n’y a pas de dates début/fin des affectations. Ce sont donc les limitations actuelles de la BD. 

1.2.	Expliquer comment vous devriez modifier le modèle logique pour que le besoin fonctionnel décrit à la question 1 soit implémenté.

Nous allons devoir ajouter une table qui relie AGENT et POSTE_DU_QUARTIER et cette table comprendre les éléments suivants : 
ID_AFFECTATION, DATE_DEBUT, DATE_FIN, FK_PDQ, FK_MATRICULE. Cette nouvelle table permettra de conserver l’historique des affectations avec leurs intervalles temporels respectifs
(relations 1 : N entre les tables).

1.3.	Advenant une telle amélioration de la base de données (question 1.2), il vous demande s’il était nécessaire d’implémenter des déclencheurs « triggers » 
afin d’assurer le maintien de l’intégrité des données lors d’insertion / mise- à-jour éventuelle de données.

Il est effectivement nécessaire d’implanter des triggers car ils empêchent certains conflits d’insertions qui peuvent survenir. 
Par exemple, si pour un agent, on tente de l’affecter a plusieurs postes de quartier pour des périodes qui entrent en conflit, un trigger empêchera ce conflit de se produire. 
De plus, un trigger s’assurera qu’une date de début d’une affectation se situera toujours avant la date de fin afin d’eviter des erreurs potentielles en interdisant 
l’insertion des affectations incorrectes –  ce qui améliore la fiabilité et l’intégrité des données.  
*/


--QUESTION 2 

USE SPVM
GO
DROP FUNCTION IF EXISTS udfGetStatsInterventions;
GO
-- Création de la fonction udfGetStatsInterventions
CREATE FUNCTION udfGetStatsInterventions(@TypeStatistique CHAR(3)) 
RETURNS INT
AS
BEGIN
    DECLARE @Resultat INT;


    IF @TypeStatistique = 'MIN'
    BEGIN
        SELECT @Resultat = MIN(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END


    ELSE IF @TypeStatistique = 'MAX'
    BEGIN
        SELECT @Resultat = MAX(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

    
    ELSE IF @TypeStatistique = 'MOY'
    BEGIN
        SELECT @Resultat = SUM(NombreIntervention) / COUNT(*)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

  
    ELSE IF @TypeStatistique = 'TOT'
    BEGIN
        SELECT @Resultat = SUM(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

  
    ELSE
    BEGIN
        SET @Resultat = -1; 
    END

    RETURN @Resultat;
END;
GO

--Question 3


DECLARE @MinInterventions INT;
DECLARE @MaxInterventions INT;
DECLARE @AvgInterventions INT;
DECLARE @TotalInterventions INT;

SET @MinInterventions = dbo.udfGetStatsInterventions('MIN');
SET @MaxInterventions = dbo.udfGetStatsInterventions('MAX');
SET @AvgInterventions = dbo.udfGetStatsInterventions('MOY');
SET @TotalInterventions = dbo.udfGetStatsInterventions('TOT');

SELECT 
    t.PDQ, -- 55 postes
    t.TotalInterventions AS [Nb. d'interventions répertoriées],
    FORMAT(ROUND(100.0 * t.TotalInterventions / @TotalInterventions, 4), 'N4') + ' %' AS [% du nb. total d'interventions], -- calculation de %
    CASE
        WHEN t.TotalInterventions = @MinInterventions 
            THEN 'PDQ avec le moins d''interventions répertoriées'
        WHEN t.TotalInterventions = @MaxInterventions 
            THEN 'PDQ avec le plus d''interventions répertoriées'
        WHEN t.TotalInterventions BETWEEN @AvgInterventions * 0.9 AND @AvgInterventions * 1.1 
            THEN 'PDQ avec un nombre d''interventions proche de la moyenne'
        WHEN t.TotalInterventions <= @AvgInterventions * 0.5 
            THEN 'PDQ avec un nombre relativement faible d''interventions'
        WHEN t.TotalInterventions >= @AvgInterventions * 1.5 
            THEN 'PDQ avec un nombre important d''interventions'
        ELSE NULL
    END AS Remarque
FROM 
    (SELECT 
        POSTE_DE_QUARTIER.ID_PDQ AS PDQ,
        COUNT(*) AS TotalInterventions
     FROM 
        INTERVENTION
     JOIN 
        INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
     JOIN 
        AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
     JOIN 
        POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
     GROUP BY 
        POSTE_DE_QUARTIER.ID_PDQ
    ) AS t
ORDER BY 
    t.PDQ;


--Question 4
GO
DROP PROCEDURE IF EXISTS spInitSuiviInterventions;
GO
CREATE PROCEDURE spInitSuiviInterventions
AS
BEGIN

	DROP TABLE IF EXISTS suiviInterventions
    CREATE TABLE suiviInterventions (
        [Poste de quartier] INT,
        [Année Mois] VARCHAR(7), -- YYYY-MM
        [Quart de travail] VARCHAR(4),
        [Nb d'interventions répertoriées] INT
    );

    INSERT INTO suiviInterventions ([Poste de quartier], [Année Mois], [Quart de travail], [Nb d'interventions répertoriées])
	SELECT 
	   PDQ AS [Poste de quartier], 
		date_intervention AS [Année Mois], 
		CASE 
			WHEN ID_QUART_TRAVAIL = 1 THEN 'JOUR'
			WHEN ID_QUART_TRAVAIL = 2 THEN 'NUIT'
			WHEN ID_QUART_TRAVAIL = 3 THEN 'SOIR'
			ELSE 'UNKNOWN'
		END AS [Quart de travail], 
		SUM(nb_intervention) AS [Nb d'interventions répertoriées]
	FROM (
		SELECT 
			AGENT.PDQ, 
			FORMAT(INTERVENTION.DATE_INCIDENT, 'yyyy-MM') AS date_intervention, 
			INTERVENTION.ID_QUART_TRAVAIL, 
			COUNT(*) AS nb_intervention
		FROM INTERVENTION
		JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
		JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
		JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
		GROUP BY 
			AGENT.PDQ, 
			FORMAT(INTERVENTION.DATE_INCIDENT, 'yyyy-MM'), 
			INTERVENTION.ID_QUART_TRAVAIL
	) AS SubQuery
	GROUP BY 
		PDQ, 
		date_intervention, 
		ID_QUART_TRAVAIL
	ORDER BY 
		PDQ, 
		date_intervention, 
		ID_QUART_TRAVAIL;
	END;	   		 	  	  
-- Execute the Procedure
EXEC spInitSuiviInterventions;
GO;

--Question 5
DROP TABLE IF EXISTS historiqueProcedure
CREATE TABLE historiqueProcedure(
	Année INT,
	Mois INT,
	[Date] DATETIME
);
DROP PROCEDURE IF EXISTS spMAJMensuelleSuiviInterventions;
GO
CREATE PROCEDURE spMAJMensuelleSuiviInterventions
AS
BEGIN
DECLARE @ceMois int
DECLARE @cetAnnée int
SET @ceMois = MONTH(GETDATE())
SET @cetAnnée = YEAR(GETDATE()) 

IF EXISTS (
	SELECT 1 FROM historiqueProcedure WHERE Année = @cetAnnée AND Mois = @ceMois
	)
	BEGIN 
	PRINT('Mise à jour déjà effectué pour :'+CONVERT(VARCHAR, @cetAnnée)+'-'+CONVERT(VARCHAR, @ceMois))
	RETURN;
END

SET NOCOUNT ON;
INSERT INTO historiqueProcedure(Année,Mois,[Date])
VALUES(@cetAnnée,@ceMois,GETDATE());
SET NOCOUNT OFF;

PRINT('Mise à jour pour :'+CONVERT(VARCHAR, @cetAnnée)+'-'+CONVERT(VARCHAR, @ceMois))
INSERT INTO suiviInterventions ([Poste de quartier], [Année Mois], [Quart de travail], [Nb d'interventions répertoriées])
	SELECT 
	   PDQ AS [Poste de quartier], 
		date_intervention AS [Année Mois], 
		CASE 
			WHEN ID_QUART_TRAVAIL = 1 THEN 'JOUR'
			WHEN ID_QUART_TRAVAIL = 2 THEN 'NUIT'
			WHEN ID_QUART_TRAVAIL = 3 THEN 'SOIR'
			ELSE 'UNKNOWN'
		END AS [Quart de travail], 
		SUM(nb_intervention) AS [Nb d'interventions répertoriées]
	FROM (
		SELECT 
			AGENT.PDQ, 
			FORMAT(INTERVENTION.DATE_INCIDENT, 'yyyy-MM') AS date_intervention, 
			INTERVENTION.ID_QUART_TRAVAIL, 
			COUNT(*) AS nb_intervention
		FROM INTERVENTION
		JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
		JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
		JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
		WHERE 
        YEAR(INTERVENTION.DATE_INCIDENT) = @cetAnnée AND 
        MONTH(INTERVENTION.DATE_INCIDENT) = @ceMois
		GROUP BY 
			AGENT.PDQ, 
			FORMAT(INTERVENTION.DATE_INCIDENT, 'yyyy-MM'), 
			INTERVENTION.ID_QUART_TRAVAIL
	) AS SubQuery
	GROUP BY 
		PDQ, 
		date_intervention, 
		ID_QUART_TRAVAIL
	ORDER BY 
		PDQ, 
		date_intervention, 
		ID_QUART_TRAVAIL;
END;	   		 	  	  

EXEC spMAJMensuelleSuiviInterventions