/* 
QUESTION 1

Votre superviseur de stage s�interroge sur la facult� de la base de donn�es actuelle � garder trace de changements �ventuels d�affectations d�un agent de police � diff�rents postes 
de quartier � travers le temps. En effet, le SPVM est dot� d�une politique permettant � un agent de police de changer d�affectation de poste de quartier pendant sa carri�re.

1.1.	Expliquer pourquoi la base de donn�es telle que con�ue, ne permet pas de consigner convenablement de tels changements d�affectation � travers le temps, afin de pouvoir l�interroger sur ces intervalles de temps d�affectation �ventuels.

Actuellement, la relation entre les tables  AGENT et POSTE_DU_QUARTIER fait en sort qu�un agent peut seulement �tre associ� � un poste de quartier � la fois. 
Donc, si un agent est affect� � un autre poste, cette nouvelle information remplacera l�ancienne et l�ancienne ne sera pas conserv�e dans la base de donn�es.
Aussi, ce qui n�est pas tr�s convenable c�est le fait qu�il n�y a pas de dates d�but/fin des affectations. Ce sont donc les limitations actuelles de la BD. 

1.2.	Expliquer comment vous devriez modifier le mod�le logique pour que le besoin fonctionnel d�crit � la question 1 soit impl�ment�.

Nous allons devoir ajouter une table qui relie AGENT et POSTE_DU_QUARTIER et cette table comprendre les �l�ments suivants : 
ID_AFFECTATION, DATE_DEBUT, DATE_FIN, FK_PDQ, FK_MATRICULE. Cette nouvelle table permettra de conserver l�historique des affectations avec leurs intervalles temporels respectifs
(relations 1 : N entre les tables).

1.3.	Advenant une telle am�lioration de la base de donn�es (question 1.2), il vous demande s�il �tait n�cessaire d�impl�menter des d�clencheurs � triggers � afin d�assurer le maintien de l�int�grit� des donn�es lors d�insertion / mise- �-jour �ventuelle de donn�es.

Il est effectivement n�cessaire d�implanter des triggers car ils emp�chent certains conflits d�insertions qui peuvent survenir. 
Par exemple, si pour un agent, on tente de l�affecter a plusieurs postes de quartier pour des p�riodes qui entrent en conflit, un trigger emp�chera ce conflit de se produire. 
De plus, un trigger s�assurera qu�une date de d�but d�une affectation se situera toujours avant la date de fin afin d�eviter des erreurs potentielles en interdisant 
l�insertion des affectations incorrectes �  ce qui am�liore la fiabilit� et l�int�grit� des donn�es.  


*/


USE SPVM

--QUESTION 2 

IF OBJECT_ID('dbo.udfGetStatsNbInterventions','FN') IS NOT NULL
BEGIN
DROP FUNCTION dbo.udfGetStatsNbInterventions;
END;
IF OBJECT_ID('udfGetStatsNbInterventions','FN') IS NOT NULL
BEGIN
DROP FUNCTION udfGetStatsNbInterventions;
END;

-- Cr�ation de la fonction udfGetStatsInterventions
CREATE FUNCTION udfGetStatsInterventions (@TypeStatistique CHAR(3)) 
RETURNS INT
AS
BEGIN
    DECLARE @Resultat INT;


    IF @TypeStatistique = 'MIN'
    BEGIN
        SELECT @Resultat = MIN(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END


    ELSE IF @TypeStatistique = 'MAX'
    BEGIN
        SELECT @Resultat = MAX(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

    
    ELSE IF @TypeStatistique = 'MOY'
    BEGIN
        SELECT @Resultat = SUM(NombreIntervention) / COUNT(*)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

  
    ELSE IF @TypeStatistique = 'TOT'
    BEGIN
        SELECT @Resultat = SUM(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

  
    ELSE
    BEGIN
        SET @Resultat = -1; 
    END

    RETURN @Resultat;
END;
GO


--Traces d�ex�cution :
PRINT 'R�sultat pour MIN : ' + CAST(dbo.udfGetStatsInterventions('MIN') AS NVARCHAR);
PRINT 'R�sultat pour MAX : ' + CAST(dbo.udfGetStatsInterventions('MAX') AS NVARCHAR);
PRINT 'R�sultat pour MOY : ' + CAST(dbo.udfGetStatsInterventions('MOY') AS NVARCHAR);
PRINT 'R�sultat pour TOT : ' + CAST(dbo.udfGetStatsInterventions('TOT') AS NVARCHAR);
PRINT 'R�sultat pour N/D : ' + CAST(dbo.udfGetStatsInterventions('N/D') AS NVARCHAR);

