<<<<<<< HEAD
--Partie 3

--QUESTION 3 YIHAN

DECLARE @MinInterventions INT;
DECLARE @MaxInterventions INT;
DECLARE @AvgInterventions INT;
DECLARE @TotalInterventions INT;


SET @MinInterventions = dbo.udfGetStatsInterventions('MIN');
SET @MaxInterventions = dbo.udfGetStatsInterventions('MAX');
SET @AvgInterventions = dbo.udfGetStatsInterventions('MOY');
SET @TotalInterventions = dbo.udfGetStatsInterventions('TOT');

--Question 3 and 4


SELECT 
    t.PDQ, -- 55 postes
    t.TotalInterventions AS [Nb. d'interventions répertoriées],
    CAST(ROUND(100.0 * t.TotalInterventions / @TotalInterventions, 4) AS NVARCHAR) + ' %' AS [% du nb. total d'interventions], -- calculation de %
    CASE
        WHEN t.TotalInterventions = @MinInterventions 
            THEN 'PDQ avec le moins d''interventions répertoriées'
        WHEN t.TotalInterventions = @MaxInterventions 
            THEN 'PDQ avec le plus d''interventions répertoriées'
        WHEN t.TotalInterventions BETWEEN @AvgInterventions * 0.9 AND @AvgInterventions * 1.1 
            THEN 'PDQ avec un nombre d''interventions proche de la moyenne'
        WHEN t.TotalInterventions <= @AvgInterventions * 0.5 
            THEN 'PDQ avec un nombre relativement faible d''interventions'
        WHEN t.TotalInterventions >= @AvgInterventions * 1.5 
            THEN 'PDQ avec un nombre important d''interventions'
        ELSE NULL
    END
FROM 
    (SELECT 
        POSTE_DE_QUARTIER.ID_PDQ AS PDQ, -- 55 postes
        COUNT(*) AS TotalInterventions
     FROM 
        INTERVENTION
     JOIN 
        INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
     JOIN 
        AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
     JOIN 
        POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
     GROUP BY 
        POSTE_DE_QUARTIER.ID_PDQ
    ) AS t
ORDER BY 
    t.PDQ;




--question 4  YIHAN
DROP PROCEDURE IF EXISTS spInitSuiviInterventions;
GO

CREATE PROCEDURE spInitSuiviInterventions
AS
BEGIN

	DROP TABLE IF EXISTS suiviInterventions

    CREATE TABLE suiviInterventions (
        poste_de_quartier INT,
        annee_mois CHAR(7), -- YYYY-MM
        quart_de_travail VARCHAR(10),
        nb_interventions INT
    );



    INSERT INTO suiviInterventions (poste_de_quartier, annee_mois, quart_de_travail, nb_interventions)
    SELECT
        PDQ.ID_PDQ AS poste_de_quartier, 
        FORMAT(INTERVENTION.DATE_INCIDENT, 'yyyy-MM') AS annee_mois,
        QUART_TRAVAIL.LIBELLÉ AS quart_de_travail,  --COLUMN JOUR NUIT SOIR
        COUNT(*) AS nb_interventions
    FROM
        INTERVENTION
    INNER JOIN
        POSTE_DE_QUARTIER PDQ ON INTERVENTION.ID_QUART_TRAVAIL = PDQ.ID_PDQ 
    INNER JOIN
        QUART_TRAVAIL ON INTERVENTION.ID_QUART_TRAVAIL = QUART_TRAVAIL.ID 
    GROUP BY
        PDQ.ID_PDQ,
        FORMAT(INTERVENTION.DATE_INCIDENT, 'yyyy-MM'),
        QUART_TRAVAIL.LIBELLÉ;

   
    SELECT 
        poste_de_quartier AS [Poste de quartier],
        annee_mois AS [Année Mois],
        quart_de_travail AS [Quart de travail],
        nb_interventions AS [Nb. d'interventions répertoriées]
    FROM 
        suiviInterventions
    ORDER BY 
        poste_de_quartier, annee_mois,
        CASE  -- I tried to make the order by JOUR NUIT SOIR for each month but it is not working at all
            WHEN quart_de_travail = 'JOUR' THEN 1
            WHEN quart_de_travail = 'NUIT' THEN 2
            WHEN quart_de_travail = 'SOIR' THEN 3
            ELSE 4
        END;
=======
/* 
QUESTION 1

Votre superviseur de stage s�interroge sur la facult� de la base de donn�es actuelle � garder trace de changements �ventuels d�affectations d�un agent de police � diff�rents postes 
de quartier � travers le temps. En effet, le SPVM est dot� d�une politique permettant � un agent de police de changer d�affectation de poste de quartier pendant sa carri�re.

1.1.	Expliquer pourquoi la base de donn�es telle que con�ue, ne permet pas de consigner convenablement de tels changements d�affectation � travers le temps, afin de pouvoir l�interroger sur ces intervalles de temps d�affectation �ventuels.

Actuellement, la relation entre les tables  AGENT et POSTE_DU_QUARTIER fait en sort qu�un agent peut seulement �tre associ� � un poste de quartier � la fois. 
Donc, si un agent est affect� � un autre poste, cette nouvelle information remplacera l�ancienne et l�ancienne ne sera pas conserv�e dans la base de donn�es.
Aussi, ce qui n�est pas tr�s convenable c�est le fait qu�il n�y a pas de dates d�but/fin des affectations. Ce sont donc les limitations actuelles de la BD. 

1.2.	Expliquer comment vous devriez modifier le mod�le logique pour que le besoin fonctionnel d�crit � la question 1 soit impl�ment�.

Nous allons devoir ajouter une table qui relie AGENT et POSTE_DU_QUARTIER et cette table comprendre les �l�ments suivants : 
ID_AFFECTATION, DATE_DEBUT, DATE_FIN, FK_PDQ, FK_MATRICULE. Cette nouvelle table permettra de conserver l�historique des affectations avec leurs intervalles temporels respectifs
(relations 1 : N entre les tables).

1.3.	Advenant une telle am�lioration de la base de donn�es (question 1.2), il vous demande s�il �tait n�cessaire d�impl�menter des d�clencheurs � triggers � afin d�assurer le maintien de l�int�grit� des donn�es lors d�insertion / mise- �-jour �ventuelle de donn�es.

Il est effectivement n�cessaire d�implanter des triggers car ils emp�chent certains conflits d�insertions qui peuvent survenir. 
Par exemple, si pour un agent, on tente de l�affecter a plusieurs postes de quartier pour des p�riodes qui entrent en conflit, un trigger emp�chera ce conflit de se produire. 
De plus, un trigger s�assurera qu�une date de d�but d�une affectation se situera toujours avant la date de fin afin d�eviter des erreurs potentielles en interdisant 
l�insertion des affectations incorrectes �  ce qui am�liore la fiabilit� et l�int�grit� des donn�es.  


*/


USE SPVM

--QUESTION 2 

IF OBJECT_ID('dbo.udfGetStatsNbInterventions','FN') IS NOT NULL
BEGIN
DROP FUNCTION dbo.udfGetStatsNbInterventions;
END;
IF OBJECT_ID('udfGetStatsNbInterventions','FN') IS NOT NULL
BEGIN
DROP FUNCTION udfGetStatsNbInterventions;
END;

-- Cr�ation de la fonction udfGetStatsInterventions
CREATE FUNCTION udfGetStatsInterventions (@TypeStatistique CHAR(3)) 
RETURNS INT
AS
BEGIN
    DECLARE @Resultat INT;


    IF @TypeStatistique = 'MIN'
    BEGIN
        SELECT @Resultat = MIN(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END


    ELSE IF @TypeStatistique = 'MAX'
    BEGIN
        SELECT @Resultat = MAX(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

    
    ELSE IF @TypeStatistique = 'MOY'
    BEGIN
        SELECT @Resultat = SUM(NombreIntervention) / COUNT(*)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

  
    ELSE IF @TypeStatistique = 'TOT'
    BEGIN
        SELECT @Resultat = SUM(NombreIntervention)
        FROM
        (
            SELECT COUNT(*) AS NombreIntervention
            FROM INTERVENTION
            JOIN INTERVENTION_AGENT ON INTERVENTION.ID_INTERVENTION = INTERVENTION_AGENT.ID_INTERVENTION
            JOIN AGENT ON INTERVENTION_AGENT.MATRICULE_AGENT = AGENT.MATRICULE
            JOIN POSTE_DE_QUARTIER ON AGENT.PDQ = POSTE_DE_QUARTIER.ID_PDQ
            GROUP BY POSTE_DE_QUARTIER.ID_PDQ
        ) AS SubQuery;
    END

  
    ELSE
    BEGIN
        SET @Resultat = -1; 
    END

    RETURN @Resultat;
>>>>>>> 973d5f2684f402b022c6d272e31cbe04ca4e38e7
END;
GO


<<<<<<< HEAD

-- Execute the Procedure
EXEC spInitSuiviInterventions;

-- Query the Table
SELECT * FROM suiviInterventions ORDER BY 1, 2, 3; 
=======
--Traces d�ex�cution :
PRINT 'R�sultat pour MIN : ' + CAST(dbo.udfGetStatsInterventions('MIN') AS NVARCHAR);
PRINT 'R�sultat pour MAX : ' + CAST(dbo.udfGetStatsInterventions('MAX') AS NVARCHAR);
PRINT 'R�sultat pour MOY : ' + CAST(dbo.udfGetStatsInterventions('MOY') AS NVARCHAR);
PRINT 'R�sultat pour TOT : ' + CAST(dbo.udfGetStatsInterventions('TOT') AS NVARCHAR);
PRINT 'R�sultat pour N/D : ' + CAST(dbo.udfGetStatsInterventions('N/D') AS NVARCHAR);
>>>>>>> 973d5f2684f402b022c6d272e31cbe04ca4e38e7

